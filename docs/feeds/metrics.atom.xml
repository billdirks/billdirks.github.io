<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>bill's mumbles - metrics</title><link href="https://billdirks.com/" rel="alternate"></link><link href="https://billdirks.com/feeds/metrics.atom.xml" rel="self"></link><id>https://billdirks.com/</id><updated>2023-05-23T00:00:00-07:00</updated><entry><title>Building a fast metricÂ pipeline</title><link href="https://billdirks.com/building-a-fast-metric-pipeline.html" rel="alternate"></link><published>2023-05-23T00:00:00-07:00</published><updated>2023-05-23T00:00:00-07:00</updated><author><name>bill dirks</name></author><id>tag:billdirks.com,2023-05-23:/building-a-fast-metric-pipeline.html</id><summary type="html">&lt;p&gt;Building a proof of concept for a fast metric&amp;nbsp;pipeline&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Lately, I&amp;#8217;ve been frustrated with slow software.  Poor startup times, poor response times, it feels like a slog to use a lot of&amp;nbsp;tools.&lt;/p&gt;
&lt;p&gt;My path to writing software started with analyzing biological data and a lot of my interest in computing revolves around processing and getting insights from&amp;nbsp;data.&lt;/p&gt;
&lt;p&gt;Lately I&amp;#8217;ve been writing a lot of Python. While it&amp;#8217;s great to build functional things quickly, a downside is, it is&amp;nbsp;slow.&lt;/p&gt;
&lt;h1&gt;Goals&lt;/h1&gt;
&lt;p&gt;For this project I wanted to build a metric pipeline meeting the following&amp;nbsp;criteria:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I want to compute metrics over numeric&amp;nbsp;data.&lt;/li&gt;
&lt;li&gt;I want the computation to be fast. That is, how long would it take to compute metrics on 1 billion data points on my&amp;nbsp;laptop?&lt;/li&gt;
&lt;li&gt;The pipeline is allowed to see each data point exactly once.&lt;ul&gt;
&lt;li&gt;This is so we can use the pipeline for streaming data or reading&amp;nbsp;files.&lt;/li&gt;
&lt;li&gt;It encourages writing O(N)&amp;nbsp;metrics&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Metrics are defined outside of the core pipeline for easy&amp;nbsp;extension.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since metrics are defined outside of the main pipeline, I have some metric specific&amp;nbsp;criteria:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For metrics, I&amp;#8217;m willing to sacrifice exactness if I can bound the&amp;nbsp;error.&lt;/li&gt;
&lt;li&gt;The metrics should have bounded memory, independent of the data size. That is, the metric can&amp;#8217;t just store all the data to get around the seeing data once&amp;nbsp;criteria.&lt;/li&gt;
&lt;li&gt;Metrics should be summable. That is, if the same metric is computed over 2 data sets, we can combine the results to get an aggregate&amp;nbsp;result.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Metrics&lt;/h1&gt;
&lt;p&gt;I find estimating a distribution will answer most questions about one dimensional numeric data. In addition I&amp;#8217;d like to compute some descriptive statistics. The metrics I am interested in&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;min&lt;/li&gt;
&lt;li&gt;max&lt;/li&gt;
&lt;li&gt;mean&lt;/li&gt;
&lt;li&gt;a distribution&amp;nbsp;estimate&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To estimate the distribution I&amp;#8217;ve chosen to use a very slight variation of &lt;a href="https://arxiv.org/pdf/1908.10693.pdf"&gt;DDSketch&lt;/a&gt;. DDSketch is basically an algorithm for generating a histogram. It is a bit more complicated than a traditional histogram with fixed size bins because it scales the bin size to bound the relative error. That means we will likely have less bins overall and we can still make meaningful statements about percentiles. For example, we could use this distribution and infer that our estimate of the median is within 0.01% of the true empirical&amp;nbsp;median.&lt;/p&gt;
&lt;h1&gt;Pipeline&amp;nbsp;architecture&lt;/h1&gt;
&lt;p&gt;I&amp;#8217;d like to describe the architecture and some high level implementation details. The code is all in C++ and is organized into 2 logical components: the pipeline and the metrics. All the code is available &lt;a href="https://github.com/billdirks/billdirks.github.io/tree/publish/code/metric_playground"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The metric interface lives in &lt;code&gt;metric.hpp&lt;/code&gt; which defines a &lt;code&gt;Metric&lt;/code&gt; template class. The important parts of the interface&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;process&lt;/code&gt; method which takes a batch of input data and is responsible for updating the metric&amp;#8217;s state using this&amp;nbsp;data.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;value&lt;/code&gt; method which returns the current value of the metric. It should be callable and return an accurate value after any arbitrary number of calls to &lt;code&gt;process&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I have not yet implemented an &lt;code&gt;add&lt;/code&gt; method to allow combining of metrics though all the current metrics could support this type of operation. An &lt;code&gt;add&lt;/code&gt; method would allow one to distribute computations over many nodes and then combine them&amp;nbsp;afterwards.&lt;/p&gt;
&lt;p&gt;While one could envision different uses for a metrics pipeline, such as processing streaming data or batch processing, for this project I have written a pipeline that reads a data file from disk, looping over the data and calling the metrics &lt;code&gt;process&lt;/code&gt; method on each data point. The pipeline is implemented in &lt;code&gt;compute_metrics.cpp&lt;/code&gt; and we setup and run it in &lt;code&gt;main.cpp&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;Learnings&lt;/h1&gt;
&lt;p&gt;It took me a few passes before I settled on my final code optimizations. In this section I enumerate the lessons learned and the things that mattered to make progress. There were 2 classes of optimization: &lt;span class="caps"&gt;IO&lt;/span&gt; (reading the data) and&amp;nbsp;compute.&lt;/p&gt;
&lt;h2&gt;Compute&lt;/h2&gt;
&lt;p&gt;For optimizing compute, I focus on DDSketch. The other metrics were more straightforward, and while they likely can be more optimized, most of the compute time was spent in DDSketch. Since DDSketch basically produces a histogram, difficulties arise from storing and sorting the histogram as new data&amp;nbsp;arrives.&lt;/p&gt;
&lt;p&gt;There are 3 main lessons about&amp;nbsp;compute:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Choosing the correct data structure is&amp;nbsp;important.&lt;/li&gt;
&lt;li&gt;Asymptotics may matter but constants also&amp;nbsp;matter.&lt;/li&gt;
&lt;li&gt;Measuring where time is spent is important and can be&amp;nbsp;surprising.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here are the high level steps we do when creating a histogram. The &lt;code&gt;process&lt;/code&gt; method looks at each point in a batch, determines the bucket it falls into, and increments the counter on that bucket by one. The edges of the bucket are determined by DDSketch which is parameterized by the relative error we allow, in our case 0.01%. A call to &lt;code&gt;value&lt;/code&gt; will produce the current&amp;nbsp;histogram.&lt;/p&gt;
&lt;p&gt;There are a number of data structures that can store histogram data. I tried 3: &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;unordered_map&lt;/code&gt;, and &lt;code&gt;vector&lt;/code&gt; which are all available in the C++ standard&amp;nbsp;library.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;: This is a dictionary with an ordering on the keys. So every &lt;a href="https://en.cppreference.com/w/cpp/container/map"&gt;insert is &lt;code&gt;log(n)&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;n&lt;/code&gt; is the current size of the &lt;code&gt;map&lt;/code&gt;. If we insert &lt;code&gt;N&lt;/code&gt; data points the number of operations is &lt;code&gt;log(1) + log(2) + ... + log(N)&lt;/code&gt; which is &lt;code&gt;O(N log(N))&lt;/code&gt;. For my initial implementation, I computed the bucket for each data point which I used as a key into a &lt;code&gt;map&lt;/code&gt; and incremented the key&amp;#8217;s value by 1. This was disappointingly&amp;nbsp;slow.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unordered_map&lt;/code&gt;: An &lt;code&gt;unordered_map&lt;/code&gt; is like a &lt;code&gt;map&lt;/code&gt;, however, the keys are unordered. Since a histogram is ordered data, I end up ordering the &lt;code&gt;keys&lt;/code&gt; on a call to &lt;code&gt;value&lt;/code&gt;. In my code, I only call &lt;code&gt;value&lt;/code&gt; once, after I see all the data from the input file. Inserts into an &lt;code&gt;unordered_map&lt;/code&gt; are &lt;a href="https://en.cppreference.com/w/cpp/container/unordered_map"&gt;O(1) on average&lt;/a&gt;. However, we need to sort the &lt;code&gt;unordered_map&lt;/code&gt; before outputting a histogram so the asymptotic time is once again &lt;code&gt;O(N log(N))&lt;/code&gt;. The reason I chose to try &lt;code&gt;map&lt;/code&gt; first was because the asymptotic times are the same but &lt;code&gt;map&lt;/code&gt; was easier to implement since I didn&amp;#8217;t have to think about sorting. &lt;code&gt;unordered_map&lt;/code&gt; proved to be much faster, around 4X for my&amp;nbsp;data.&lt;/p&gt;
&lt;p&gt;This still proved to be slow and I hoped that I could do better so I profiled the code. I compiled my code using &lt;code&gt;gperftools&lt;/code&gt;, ran it on a test file with 100,000,000 points, and looked at the output with &lt;code&gt;gprof&lt;/code&gt;. The results were surprising. The time wasn&amp;#8217;t spent computing the bucket for a data point (my code) but instead was spent inserting numbers into the &lt;code&gt;unordered_map&lt;/code&gt; (stdlib code). That means, computing the hash for the bucket, was the most expensive operation I was&amp;nbsp;doing.&lt;/p&gt;
&lt;p&gt;I hadn&amp;#8217;t thought too hard about implementing a bound on memory usage at this point. However, now that I understood how expensive hashing was, I wanted to predetermine the amount of memory needed and store the histogram in a list. The bucket produced by DDSketch is an integer representing the first bucket, second bucket, etc, so can be used as indexes into a&amp;nbsp;list.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;: A &lt;code&gt;vector&lt;/code&gt; in C++ is a dynamically resizable list that is stored in a contiguous section of memory. In order to use it, I wanted to determine the amount of memory necessary up front so I could do 1 allocation and avoid copying and moving data around. DDSketch&amp;#8217;s strategy to bound memory usage is to predetermine the number of buckets allowed and to combine the smallest index buckets when the maximum number of buckets is reached. I&amp;#8217;m guessing this is because the authors are interested in accurately estimating the highest value percentiles (eg the p99 response time for web requests for an app). My use case is more inspired by data quality so I follow &lt;a href="https://greatexpectations.io/"&gt;Great Expectations&lt;/a&gt; lead and presume the user has some idea of the range the data should lie in. So this implementation requires the user to provide a lower and upper bound for the data. I then use these bounds to determine the number of buckets. I also add 2 additional buckets that are used when the data falls below or above this range. Using this strategy, I can preallocate the needed memory. The &lt;code&gt;vector&lt;/code&gt; data structure also lets me avoid sorting and, since inserts are O(1), this results in an O(N) algorithm. So, while the major speedup is due to eliminating hashing, rethinking the algorithm also resulted in a faster asymptotic&amp;nbsp;runtime!&lt;/p&gt;
&lt;h2&gt;&lt;span class="caps"&gt;IO&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;I like computing things and I thought the interesting part of this project would be computing metrics.  However, that wasn&amp;#8217;t right. The actual performance bottleneck was reading the data from disk, ie &lt;span class="caps"&gt;IO&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Since I didn&amp;#8217;t initially think about &lt;span class="caps"&gt;IO&lt;/span&gt; at all, I implemented reading data in the most naive way possible.  I opened a file and read in the data one point at a time like&amp;nbsp;this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# variables&lt;/span&gt;
&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ifstream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ios&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;# read the data in a loop using&lt;/span&gt;
&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I initially picked a batch size, read in at most batch size points, and updated the metrics before starting the next cycle. This was horrendously slow primarily because I was doing a separate read call for each data&amp;nbsp;point.&lt;/p&gt;
&lt;p&gt;After some searching I came across this &lt;a href="https://lemire.me/blog/2012/06/26/which-is-fastest-read-fread-ifstream-or-mmap/"&gt;fantastic blog post&lt;/a&gt; about reading data which had some &lt;a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/blob/master/2012/06/26/ioaccess.cpp"&gt;sample benchmarking code&lt;/a&gt;. Running the benchmarks on my machine indicated that &lt;code&gt;mmap&lt;/code&gt; was going to be the fastest. I did try using &lt;code&gt;ifstream&lt;/code&gt; to read in the whole file at once but &lt;code&gt;mmap&lt;/code&gt; was significantly&amp;nbsp;faster.&lt;/p&gt;
&lt;h1&gt;Setup for&amp;nbsp;Timings&lt;/h1&gt;
&lt;p&gt;All the timings were done on my laptop which is a 1st gen M1 powerbook with 16 &lt;span class="caps"&gt;GB&lt;/span&gt; of &lt;span class="caps"&gt;RAM&lt;/span&gt;. They  were done by modifying the &lt;code&gt;compute_metrics&lt;/code&gt; function in &lt;code&gt;compute_metrics.cpp&lt;/code&gt;. The function is defined&amp;nbsp;as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb nb-Type"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;compute_metrics&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MmapFile&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mmap_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ComputeMetricOutput&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;computed_metrics&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cur_ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mmap_file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;end_ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mmap_file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cur_ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;end_ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;CODE&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Where &lt;code&gt;&amp;lt;CODE&amp;gt;&lt;/code&gt; is one of three code&amp;nbsp;snippets:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reading Data&amp;nbsp;Only&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;strtod(cur_ptr, &amp;amp;cur_ptr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Compute Histogram&amp;nbsp;Only&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strtod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cur_ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cur_ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;computed_metrics&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ddsketch&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Compute Histogram and Descriptive&amp;nbsp;Metrics&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strtod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cur_ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cur_ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;computed_metrics&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ddsketch&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;computed_metrics&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;metrics&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;computed_metrics&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;metrics&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The code was built and run using the&amp;nbsp;command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;make clean
make compute_opt
rm o
gtime -v build/compute data/&amp;lt;datafile&amp;gt; &amp;gt; o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I use the compiler flag &lt;code&gt;-O3&lt;/code&gt;. This optimizes for speed (as opposed to binary size) while keeping the computations accurate. That is, one can get faster binaries if one is willing to do inaccurate math, but this is antithetical to what I am trying to&amp;nbsp;do.&lt;/p&gt;
&lt;p&gt;The data was generated using the code in &lt;code&gt;random_number.cpp&lt;/code&gt; which can be compiled as run as&amp;nbsp;follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;g++ -Wall --std=c++20 -Iinclude -O3 utils/random_number.cpp -o random_number
./random_number
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Running it produces a 100 million normally distributed ascii encoded&amp;nbsp;numbers.&lt;/p&gt;
&lt;h3&gt;Timings&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;gtime -v&lt;/code&gt; prints out some nice diagnostic information about a pipeline run. To determine speed I report the &lt;code&gt;Elapsed (wall clock) time&lt;/code&gt;. I did timings with 2 data sets, one with 100 million data points and one with 1 billion data points. If I run the pipeline more than once in succession subsequent runs are significantly faster since the &lt;span class="caps"&gt;OS&lt;/span&gt; caches data. To normalize for this I reboot between timings. I report timing both the &amp;#8220;cold&amp;#8221; and &amp;#8220;hot&amp;#8221;&amp;nbsp;runs.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Number of data points&lt;/th&gt;
&lt;th&gt;Cold Speed&lt;/th&gt;
&lt;th&gt;Hot Speed&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Reading Data Only&lt;/td&gt;
&lt;td&gt;100 million&lt;/td&gt;
&lt;td&gt;3.69 s&lt;/td&gt;
&lt;td&gt;1.89 s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compute Histogram Only&lt;/td&gt;
&lt;td&gt;100 million&lt;/td&gt;
&lt;td&gt;4.21 s&lt;/td&gt;
&lt;td&gt;2.45 s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compute Histogram and Descriptive Metrics&lt;/td&gt;
&lt;td&gt;100 million&lt;/td&gt;
&lt;td&gt;4.59 s&lt;/td&gt;
&lt;td&gt;2.81 s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reading Data Only&lt;/td&gt;
&lt;td&gt;1 billion&lt;/td&gt;
&lt;td&gt;32.40 s&lt;/td&gt;
&lt;td&gt;17.31 s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compute Histogram Only&lt;/td&gt;
&lt;td&gt;1 billion&lt;/td&gt;
&lt;td&gt;39.14 s&lt;/td&gt;
&lt;td&gt;23.24 s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compute Histogram and Descriptive Metrics&lt;/td&gt;
&lt;td&gt;1 billion&lt;/td&gt;
&lt;td&gt;41.84 s&lt;/td&gt;
&lt;td&gt;26.19 s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From these measurements we see that, despite focusing on what I thought was a computational problem, reading in the data dominates the timings. While I would need to do more timings, the cold runs suggest a possible linear scaling. If I don&amp;#8217;t reboot between runs and have other apps running (eg browser, editor) the 100 million data point runs are very similar to what I report here while the 1 billion data point runs are seconds slower and the &amp;#8220;hot&amp;#8221; runs take the same amount of time as the &amp;#8220;cold&amp;#8221;&amp;nbsp;runs.&lt;/p&gt;
&lt;p&gt;I also examined the memory output of &lt;code&gt;gtime -v&lt;/code&gt;.  Both data sets fit completely into memory and, for a particular data set, the same amount of memory is used across&amp;nbsp;runs.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Number of data points&lt;/th&gt;
&lt;th&gt;File size&lt;/th&gt;
&lt;th&gt;Max resident memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100 million&lt;/td&gt;
&lt;td&gt;744 &lt;span class="caps"&gt;MB&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;745 &lt;span class="caps"&gt;MB&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1 billion&lt;/td&gt;
&lt;td&gt;6753 &lt;span class="caps"&gt;MB&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;6754 &lt;span class="caps"&gt;MB&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;Comparison to&amp;nbsp;Python&lt;/h1&gt;
&lt;p&gt;Since I spend a lot of time looking at Python code, I was curious how fast a similar computation would be there. For this quick comparison, I only looked at computing a histogram using numpy. This would be comparable to the &amp;#8220;Compute Histogram Only&amp;#8221; numbers, however, the Python histogram is a little simpler to compute than DDSketch. I also don&amp;#8217;t write the histogram data to a file. This gives the Python code a slight advantage. The script I used&amp;nbsp;was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pandas&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt;

&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pandas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_csv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/path/to/data.csv&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;hist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kp"&gt;histogram&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;80591&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10000000&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Number of data points&lt;/th&gt;
&lt;th&gt;Speed&lt;/th&gt;
&lt;th&gt;Max resident memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;100 million&lt;/td&gt;
&lt;td&gt;5.84 s&lt;/td&gt;
&lt;td&gt;2262 &lt;span class="caps"&gt;MB&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;100 million&lt;/td&gt;
&lt;td&gt;4.21 s&lt;/td&gt;
&lt;td&gt;745 &lt;span class="caps"&gt;MB&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;1 billion&lt;/td&gt;
&lt;td&gt;48.20 s&lt;/td&gt;
&lt;td&gt;8773 &lt;span class="caps"&gt;MB&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;1 billion&lt;/td&gt;
&lt;td&gt;39.14 s&lt;/td&gt;
&lt;td&gt;6754 &lt;span class="caps"&gt;MB&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The Python code is significantly slower and consumes more memory but is much, much simpler. Most of the time in Python was also spent in &lt;span class="caps"&gt;IO&lt;/span&gt; (~4.8 s and ~40.3&amp;nbsp;s).&lt;/p&gt;
&lt;h1&gt;Final&amp;nbsp;Thoughts&lt;/h1&gt;
&lt;p&gt;This project was a lot of fun! The two things I found surprising, but are &amp;#8220;obvious&amp;#8221; in&amp;nbsp;retrospect:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I thought compute would dominate the timings since this project was about summarizing data but &lt;span class="caps"&gt;IO&lt;/span&gt; dominates. The reason is, I&amp;#8217;m not doing very many operations on any data point and the most complicated operation I&amp;#8217;m doing is taking a&amp;nbsp;log.&lt;/li&gt;
&lt;li&gt;Using a map was slow since computing hashes is more expensive than computing the index (bucket id) into a vector. Having written mostly Python recently where dictionaries are a very common data structure it was good to be reminded of their&amp;nbsp;cost.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I also wanted to highlight 2 lessons that I took&amp;nbsp;away:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Experimenting by benchmarking is very helpful. I was lucky that I came across Daniel Lemire&amp;#8217;s blog and could use his code to do timings of different &lt;span class="caps"&gt;IO&lt;/span&gt;&amp;nbsp;strategies.&lt;/li&gt;
&lt;li&gt;Profilings code is helpful and often surprising. I was very focused on the map data structures and it took the nudge from profiling to make me think of a different strategy&amp;nbsp;altogether.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Even though my code has a lot of shortcomings (eg I assume the data is well formed and only contains 1 column), it did teach me about data processing bottlenecks. I see why people develop new data formats and why so much attention is spent on &lt;span class="caps"&gt;IO&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Thanks for&amp;nbsp;reading!&lt;/p&gt;</content><category term="metrics"></category><category term="c++"></category><category term="performance"></category><category term="metrics"></category></entry></feed>